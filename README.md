# Prova Finale Reti Logiche 2018/2019

Final project of the "Reti Logiche" course 2018/2019.\
Developed by Diego Savoia and [Francesco Emanuele Stradi](https://github.com/FrancescoEmanueleStradi).

## Description
The complete description of the project can be found in the [official PDF file](https://github.com/savoiadiego/prova-finale-reti-logiche-2018-2019/blob/main/Project%20Description.pdf) (in Italian).

Given a bidimensional space (a 256x256 square) and the position of N points (centroids), the goal was to implement a HW component described in VHDL language that, once received the coordinates of a new point, is able to determine which is (are) the nearest centroid(s).\
The coordinates of the centroids and of the point to evaluate are stored in a memory, whose implementation was not part of the project.\
The output is a binary mask having one bit for each centroid: a bit is set to 1 if that centroid is the nearest one, otherwise it is set to 0. In case of ties, all the corresponding bits are set to 1.\
In particular, it is not necessary to evaluate all the centroids. An input binary mask specifies which centroids are the ones to consider. Again, a bit is set to 1 if that centroid is to be considered for the evaluation, otherwise it is set to 0.

### Data
Each data has a dimension of 8 bits, and they are stored in a Byte-addressable memory, starting from Byte 0. The structure is the following one:
* Byte 0: input binary mask
* Bytes 1 - 16: centroids coordinates
  * 1: X-coordinate of centroid 1
  * 2: Y-coordinate of centroid 1
  * 3: X-coordinate of centroid 2
  * 4: Y-coordinate of centroid 2
  * ...
  * 15: X-coordinate of centroid 8
  * 16: Y-coordinate of centroid 8
* Byte 17: X-coordinate of the point to evaluate
* Byte 18: Y-coordinate of the point to evaluate
* Byte 19: output binary mask

### Additional Information
Centroids in the binary masks are listed starting from the least significant bit: this means that the right most position refers to centroid 1, while the left most position refers to centroid 8.\
The implemented module starts working when a START signal in input is set to 1. Then, after the module writes the output binary mask in memory, it sets a DONE signal to 1. When this happens, the START signal is set to 0 and finally the DONE signal is set to 0. Notice that a new START signal cannot be sent until the DONE signal has been reset to 0.

### Component Interface
As explained in the project description file, the component must have the following interface:
```vhdl
entity project_reti_logiche is
    Port ( i_clk : in STD_LOGIC;
           i_start : in STD_LOGIC;
           i_rst : in STD_LOGIC;
           i_data : in STD_LOGIC_VECTOR(7 downto 0);
           o_address : out STD_LOGIC_VECTOR(15 downto 0);
           o_done : out STD_LOGIC;
           o_en : out STD_LOGIC;
           o_we : out STD_LOGIC;
           o_data : out STD_LOGIC_VECTOR(7 downto 0));
end project_reti_logiche;
```
In particular:
* _i_clk_ is the input CLOCK signal generated by the test_bench
* _i_start_ is the START signal generated by the test_bench
* i_rst_ is the RESET signal that initialize the machine to be ready to receive the first START signal
* _i_data_ is the signal (vector) coming from the memory after a read request
* _o_address_ is the output signal (vector) to specify the memory address
* _o_done_ is the output DONE signal meaning that the computation is finished and the output binary mask has been stored in memory
* _o_en_ is the ENABLE signal to be sent to the memory in order to communicate (both to read and write)
* _o_we_ is the WRITE ENABLE signal to be sent to the memory (=1) in order to write. It is set to 0 if the module reads from the memory
* _o_data_ is the output signal (vector) containing the data to be stored in memory

## Implementation
The module is implemented in the _code.vhd_ file. A _test_bench.vhd_ file is also present, and it was provided along with the project description.\
Finally, the [Report.pdf file](https://github.com/savoiadiego/prova-finale-reti-logiche-2018-2019/blob/main/Report.pdf) was written after the implementation and it is available in this repository (in Italian). It contains a recap of the project specifications, the design choices, some test cases and the synthesis results.
